class WMLAction::Parser

prechigh
  nonassoc EUMIN
  left '*' '/'
  left '+' '-' '.'
preclow

rule
    target      : /* nothing */
                | wml_doc { log.debug 'Found a target' }

    wml_doc     : tag { log.debug 'Found a doc' }

    tag         : OTAG contents CTAG { log.debug("Creating tag #{val[0]}"); return Tag.new(name: val[0], content: val[1]) }

    contents    : /* nothing */     { return [] }
                | contents content  { log.debug("Append #{val[1]} to #{val[0]}"); return val[0]? val[0].push(val[1]) : [val[1]] }

    content     : action
                | tag      { log.debug "Found a content subtag #{val[0]}" }
                | attribute
                | filter
                | MACRO    { log.debug "Found a macro #{val[0]}"; return Tag::Macro[val[0]] }
    
    expression  : BACKQ expr BACKQ { return val[1] }

    expr        : expr EPLUS expr { log.debug "Found a #{val[0]} #{val[1]} #{val[2]} expression"; return val[0] << val[2] << Tag::Expr[Tag::Expr::Op[val[1]]] }
                | expr EMINUS expr { log.debug "Found a #{val[0]} #{val[1]} #{val[2]} expression"; return val[0] << val[2] << Tag::Expr[Tag::Expr::Op[val[1]]] } 
                | expr EMUL expr { log.debug "Found a #{val[0]} #{val[1]} #{val[2]} expression"; return val[0] << val[2] << Tag::Expr[Tag::Expr::Op[val[1]]] }
                | expr EDIV expr { log.debug "Found a #{val[0]} #{val[1]} #{val[2]} expression"; return val[0] << val[2] << Tag::Expr[Tag::Expr::Op[val[1]]] }
                | expr EDOT expr { log.debug "Found a #{val[0]} #{val[1]} #{val[2]} expression"; return val[0] << val[2] << Tag::Expr[Tag::Expr::Op[val[1]]] }
                | EMINUS ENUMBER =EUMIN { return Tag:Expr[-val[1]] }
                | '(' expr ')' { return val[1] }
                | ESTR { log.debug "Found a string #{val[0]}"; return Tag::Expr[val[0]] }
                | ENUM { log.debug "Found a number #{val[0]}"; return Tag::Expr[val[0]] }
                | EVAR { log.debug "Found a variable #{val[0]}"; return Tag::Expr[Tag::Expr::Var[val[0]]] }

    action      : aop tag { log.debug "Found a action tag #{val[0]}:#{val[1]}"; return Tag::Action[val[1],val[0]] }
                | aop MACRO { log.debug "Found a action macro #{val[0]}:#{val[1]}"; return Tag::Action[Tag::Macro[val[1]],val[0]] }

    aop         : '+'
                | '-'

    attribute   : ATTR          { log.debug "Found empty attribute: #{val[0]}"; return Tag::Attribute[val[0],''] }
                | ATTR APLAIN   { log.debug "Found plain attribute: #{val[0]}:#{val[1]}"; return Tag::Attribute[val[0],val[1]] }
                | ATTR string_val     { log.debug "Found string attribute: #{val[0]}:#{val[1]}"; return Tag::Attribute[val[0],val[1]] }
                | ATTR AMACRO   { log.debug "Found macro attribute: #{val[0]}:#{val[1]}"; return Tag::Attribute[val[0],val[1]] }
                | ATTR ANUMBER  { log.debug "Found numeric attribute: #{val[0]}:#{val[1]}"; return Tag::Attribute[val[0],val[1]]  }
                | ATTR expression { log.debug "Found expression attribute: #{val[0]}"; return Tag::Attribute[val[0],val[1]] }

    string_val  : ASTR { return " #{val[0]}" }
                | UNDERSC ASTR { return ' '+val[0]+' '+val[1] }
                | string_val APLUS AMACRO { return val[0] + '+' + val[2] }

    filter      : SLASH attribute { log.debug "Found an attribute filter #{val[1]}"; return Tag::Filter[val[1]] }
                | SLASH MACRO { log.debug "Found a macro filter #{val[1]}"; return Tag::Filter[Tag::Macro[val[1]]] }

end

---- header ----
#
# generated by racc
#
require 'wml_action/lexer.rex'
require 'wml_action/tag'
require 'wml_action/log'

---- inner ----
include Log

---- footer ----

